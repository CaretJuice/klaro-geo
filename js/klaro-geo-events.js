/**
 * Klaro Geo Events Factory
 *
 * Centralized module for creating dataLayer events with:
 * - Fresh consent state (not stale references)
 * - Correct eventSource values
 * - Consistent event structure
 *
 * eventSource Rules:
 * - 'klaro': Events forwarded from Klaro library (manager.watch, initial state)
 * - 'klaro-geo': Events generated by klaro-geo plugin
 */
(function() {
    'use strict';

    // Event source constants
    var SOURCE_KLARO = 'klaro';
    var SOURCE_KLARO_GEO = 'klaro-geo';

    /**
     * Get the service consent key from a service name.
     * For consent mode services (is_consent_mode_service=true), returns the consent_mode_key
     * directly (e.g., "analytics_storage"). For regular services, appends "_consent"
     * (e.g., "google_analytics_consent").
     * @param {string} serviceName - The service name (e.g., "google-analytics")
     * @returns {string} - The consent key
     */
    function getServiceConsentKey(serviceName) {
        // Check if this is a consent mode service with a dedicated key
        if (typeof window.klaroConfig !== 'undefined' && window.klaroConfig.services) {
            for (var i = 0; i < window.klaroConfig.services.length; i++) {
                var service = window.klaroConfig.services[i];
                if (service.name === serviceName && service.is_consent_mode_service && service.consent_mode_key) {
                    return service.consent_mode_key;
                }
            }
        }
        return serviceName.replace(/-/g, '_') + '_consent';
    }

    /**
     * Get fresh consent state from Klaro manager
     * Always retrieves current state to avoid stale data
     * @returns {Object} Current consent state with manager, consents, acceptedServices, and consentMode
     */
    function getConsentState() {
        var manager = null;
        var consents = {};

        try {
            if (typeof window.klaro !== 'undefined' && typeof window.klaro.getManager === 'function') {
                manager = window.klaro.getManager();
                if (manager && manager.consents) {
                    // Deep copy to capture current state (not a reference that changes later)
                    consents = JSON.parse(JSON.stringify(manager.consents));
                }
            }
        } catch (e) {
            klaroGeoLog('DEBUG: KlaroGeoEvents.getConsentState error:', e);
        }

        var acceptedServices = Object.keys(consents).filter(function(k) {
            return consents[k] === true;
        });

        return {
            manager: manager,
            consents: consents,
            acceptedServices: acceptedServices,
            consentMode: buildConsentMode(consents, manager)
        };
    }

    /**
     * Get consent mode service map.
     * Maps consent_mode_key (e.g., 'ad_storage') to service name (e.g., 'ad-storage').
     * Prefers klaroConsentData, falls back to deriving from klaroConfig.services.
     * @returns {Object} Map of consent_mode_key to service_name
     */
    function getConsentModeServiceMap() {
        if (typeof window.klaroConsentData !== 'undefined' &&
            window.klaroConsentData.consentModeServices) {
            return window.klaroConsentData.consentModeServices;
        }
        // Fallback: derive from klaroConfig.services
        var map = {};
        if (typeof window.klaroConfig !== 'undefined' && window.klaroConfig.services) {
            window.klaroConfig.services.forEach(function(service) {
                if (service.is_consent_mode_service && service.consent_mode_key) {
                    map[service.consent_mode_key] = service.name;
                }
            });
        }
        return map;
    }

    /**
     * Get parent-child service map.
     * Maps parent service name to array of child service names.
     * Prefers klaroConsentData, falls back to deriving from klaroConfig.services.
     * @returns {Object} Map of parent service name to array of child service names
     */
    function getParentChildMap() {
        if (typeof window.klaroConsentData !== 'undefined' &&
            window.klaroConsentData.parentChildMap) {
            return window.klaroConsentData.parentChildMap;
        }
        // Fallback: derive from klaroConfig.services
        var map = {};
        if (typeof window.klaroConfig !== 'undefined' && window.klaroConfig.services) {
            window.klaroConfig.services.forEach(function(service) {
                if (service.parent_service) {
                    if (!map[service.parent_service]) {
                        map[service.parent_service] = [];
                    }
                    map[service.parent_service].push(service.name);
                }
            });
        }
        return map;
    }

    /**
     * Build Google Consent Mode object from consents
     * Uses consent mode services (is_consent_mode_service=true) to map service consent
     * to standard Google Consent Mode keys (ad_storage, analytics_storage, etc.)
     *
     * @param {Object} consents - Service consents object
     * @param {Object} manager - Klaro manager (optional, for config access)
     * @returns {Object} Google Consent Mode formatted object
     */
    function buildConsentMode(consents, manager) {
        var consentMode = {};

        // Get consent mode service map from PHP-generated config
        var consentModeServiceMap = getConsentModeServiceMap();
        var parentChildMap = getParentChildMap();

        // Process consent mode services - map their consent state to standard Google keys
        Object.keys(consentModeServiceMap).forEach(function(consentModeKey) {
            var serviceName = consentModeServiceMap[consentModeKey];
            var isGranted = consents[serviceName] === true;
            consentMode[consentModeKey] = isGranted ? 'granted' : 'denied';
        });

        // Enforce parent-child dependencies
        // If parent is denied, children must also be denied
        Object.keys(parentChildMap).forEach(function(parentName) {
            var children = parentChildMap[parentName];
            var parentConsented = consents[parentName] === true;
            if (!parentConsented) {
                // Parent is denied - ensure all children are also denied
                children.forEach(function(childName) {
                    // Find the consent mode key for this child service
                    Object.keys(consentModeServiceMap).forEach(function(key) {
                        if (consentModeServiceMap[key] === childName) {
                            consentMode[key] = 'denied';
                        }
                    });
                });
            }
        });

        // Add dynamic service consent keys for ALL services
        Object.keys(consents).forEach(function(serviceName) {
            var dynamicKey = getServiceConsentKey(serviceName);
            consentMode[dynamicKey] = consents[serviceName] === true ? 'granted' : 'denied';
        });

        return consentMode;
    }

    /**
     * Create an event forwarded from Klaro library
     * Uses eventSource: 'klaro' for events that originate from Klaro
     *
     * @param {string} eventName - The Klaro event name (e.g., 'saveConsents', 'initialConsents')
     * @param {*} eventData - The event data from Klaro
     * @returns {Object} DataLayer event object
     */
    function createKlaroForwardedEvent(eventName, eventData) {
        var state = getConsentState();

        return {
            'event': 'Klaro Event',
            'eventSource': SOURCE_KLARO,
            'klaroEventName': eventName,
            'klaroEventData': eventData,
            'acceptedServices': state.acceptedServices
        };
    }

    /**
     * Create an event generated by klaro-geo plugin
     * Uses eventSource: 'klaro-geo' for plugin-generated events
     *
     * @param {string} eventName - The event name (e.g., 'generateConsentReceipt')
     * @param {Object} additionalData - Additional data to include in the event
     * @returns {Object} DataLayer event object
     */
    function createKlaroGeoEvent(eventName, additionalData) {
        var event = {
            'event': 'Klaro Event',
            'eventSource': SOURCE_KLARO_GEO,
            'klaroEventName': eventName
        };

        // Merge additional data
        if (additionalData && typeof additionalData === 'object') {
            Object.keys(additionalData).forEach(function(key) {
                event[key] = additionalData[key];
            });
        }

        return event;
    }

    /**
     * Create consent update event
     * Pushed directly by the plugin after gtag('consent', 'update') is called
     *
     * @param {string} triggerEvent - The event that triggered this (e.g., 'initialConsents', 'saveConsents')
     * @returns {Object} DataLayer event object
     */
    function createConsentUpdateEvent(triggerEvent) {
        var state = getConsentState();

        return {
            'event': 'Klaro Consent Update',
            'consent_trigger': triggerEvent,
            'consentMode': state.consentMode,
            'acceptedServices': state.acceptedServices
        };
    }

    /**
     * Create consent receipt event
     *
     * @param {Object} consentReceipt - The consent receipt object
     * @param {boolean} includeDetails - Whether to include additional details
     * @returns {Object} DataLayer event object
     */
    function createConsentReceiptEvent(consentReceipt, includeDetails) {
        var event = {
            'event': 'Klaro Geo Consent Receipt',
            'klaro_geo_consent_receipt': consentReceipt
        };

        if (includeDetails) {
            event['klaro_geo_template_source'] = consentReceipt.template_source;
            event['klaro_geo_admin_override'] = consentReceipt.admin_override;
        }

        return event;
    }

    // Export to global namespace
    window.KlaroGeoEvents = {
        // Constants
        SOURCE_KLARO: SOURCE_KLARO,
        SOURCE_KLARO_GEO: SOURCE_KLARO_GEO,

        // Functions
        getConsentState: getConsentState,
        getServiceConsentKey: getServiceConsentKey,
        buildConsentMode: buildConsentMode,
        createKlaroForwardedEvent: createKlaroForwardedEvent,
        createKlaroGeoEvent: createKlaroGeoEvent,
        createConsentUpdateEvent: createConsentUpdateEvent,
        createConsentReceiptEvent: createConsentReceiptEvent
    };

    klaroGeoLog('DEBUG: KlaroGeoEvents module loaded');
})();
