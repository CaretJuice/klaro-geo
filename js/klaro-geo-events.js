/**
 * Klaro Geo Events Factory
 *
 * Centralized module for creating dataLayer events with:
 * - Fresh consent state (not stale references)
 * - Correct eventSource values
 * - Consistent event structure
 *
 * eventSource Rules:
 * - 'klaro': Events forwarded from Klaro library (manager.watch, initial state)
 * - 'klaro-geo': Events generated by klaro-geo plugin
 */
(function() {
    'use strict';

    // Event source constants
    var SOURCE_KLARO = 'klaro';
    var SOURCE_KLARO_GEO = 'klaro-geo';

    /**
     * Get the service consent key from a service name
     * @param {string} serviceName - The service name (e.g., "google-analytics")
     * @returns {string} - The consent key (e.g., "google_analytics_consent")
     */
    function getServiceConsentKey(serviceName) {
        return serviceName.replace(/-/g, '_') + '_consent';
    }

    /**
     * Get fresh consent state from Klaro manager
     * Always retrieves current state to avoid stale data
     * @returns {Object} Current consent state with manager, consents, acceptedServices, and consentMode
     */
    function getConsentState() {
        var manager = null;
        var consents = {};

        try {
            if (typeof window.klaro !== 'undefined' && typeof window.klaro.getManager === 'function') {
                manager = window.klaro.getManager();
                if (manager && manager.consents) {
                    // Deep copy to capture current state (not a reference that changes later)
                    consents = JSON.parse(JSON.stringify(manager.consents));
                }
            }
        } catch (e) {
            klaroGeoLog('DEBUG: KlaroGeoEvents.getConsentState error:', e);
        }

        var acceptedServices = Object.keys(consents).filter(function(k) {
            return consents[k] === true;
        });

        return {
            manager: manager,
            consents: consents,
            acceptedServices: acceptedServices,
            consentMode: buildConsentMode(consents, manager)
        };
    }

    /**
     * Build Google Consent Mode object from consents
     * @param {Object} consents - Service consents object
     * @param {Object} manager - Klaro manager (optional, for config access)
     * @returns {Object} Google Consent Mode formatted object
     */
    function buildConsentMode(consents, manager) {
        var consentMode = {};

        // Get consent mode settings from config if available
        var adStorageService = window.adStorageServiceName;
        var analyticsStorageService = window.analyticsStorageServiceName;

        // Check service consent status
        var adServiceEnabled = adStorageService && consents[adStorageService] === true;
        var analyticsServiceEnabled = analyticsStorageService && consents[analyticsStorageService] === true;

        // Standard Google Consent Mode keys
        consentMode['ad_storage'] = adServiceEnabled ? 'granted' : 'denied';
        consentMode['analytics_storage'] = analyticsServiceEnabled ? 'granted' : 'denied';
        consentMode['ad_user_data'] = (adServiceEnabled && window.adUserDataConsent === true) ? 'granted' : 'denied';
        consentMode['ad_personalization'] = (adServiceEnabled && window.adPersonalizationConsent === true) ? 'granted' : 'denied';

        // Reserved keys that dynamic service keys should not overwrite
        var reservedKeys = ['ad_storage', 'analytics_storage', 'ad_user_data', 'ad_personalization'];

        // Add dynamic service consent keys for ALL services
        Object.keys(consents).forEach(function(serviceName) {
            var dynamicKey = getServiceConsentKey(serviceName);
            // Only add if not conflicting with reserved keys
            if (!reservedKeys.includes(dynamicKey.replace('_consent', ''))) {
                consentMode[dynamicKey] = consents[serviceName] === true ? 'granted' : 'denied';
            }
        });

        return consentMode;
    }

    /**
     * Create an event forwarded from Klaro library
     * Uses eventSource: 'klaro' for events that originate from Klaro
     *
     * @param {string} eventName - The Klaro event name (e.g., 'saveConsents', 'initialConsents')
     * @param {*} eventData - The event data from Klaro
     * @param {Object} config - The Klaro config object
     * @returns {Object} DataLayer event object
     */
    function createKlaroForwardedEvent(eventName, eventData, config) {
        var state = getConsentState();

        return {
            'event': 'Klaro Event',
            'eventSource': SOURCE_KLARO,
            'klaroEventName': eventName,
            'klaroEventData': eventData,
            'klaroConfig': config,
            'acceptedServices': state.acceptedServices
        };
    }

    /**
     * Create an event generated by klaro-geo plugin
     * Uses eventSource: 'klaro-geo' for plugin-generated events
     *
     * @param {string} eventName - The event name (e.g., 'generateConsentReceipt')
     * @param {Object} additionalData - Additional data to include in the event
     * @returns {Object} DataLayer event object
     */
    function createKlaroGeoEvent(eventName, additionalData) {
        var event = {
            'event': 'Klaro Event',
            'eventSource': SOURCE_KLARO_GEO,
            'klaroEventName': eventName
        };

        // Merge additional data
        if (additionalData && typeof additionalData === 'object') {
            Object.keys(additionalData).forEach(function(key) {
                event[key] = additionalData[key];
            });
        }

        return event;
    }

    /**
     * Create consent data event for GTM
     * This event is consumed by the Klaro Geo GTM template
     *
     * @param {string} triggerEvent - The event that triggered this (e.g., 'initialConsents', 'saveConsents')
     * @returns {Object} DataLayer event object
     */
    function createConsentDataEvent(triggerEvent) {
        var state = getConsentState();

        return {
            'event': 'Klaro Consent Data',
            'eventSource': SOURCE_KLARO_GEO,
            'consentMode': state.consentMode,
            'acceptedServices': state.acceptedServices,
            'triggerEvent': triggerEvent
        };
    }

    /**
     * Create consent receipt event
     *
     * @param {Object} consentReceipt - The consent receipt object
     * @param {boolean} includeDetails - Whether to include additional details
     * @returns {Object} DataLayer event object
     */
    function createConsentReceiptEvent(consentReceipt, includeDetails) {
        var event = {
            'event': 'Klaro Geo Consent Receipt',
            'eventSource': SOURCE_KLARO_GEO,
            'klaro_geo_consent_receipt': consentReceipt
        };

        if (includeDetails) {
            event['klaro_geo_template_source'] = consentReceipt.template_source;
            event['klaro_geo_admin_override'] = consentReceipt.admin_override;
        }

        return event;
    }

    // Export to global namespace
    window.KlaroGeoEvents = {
        // Constants
        SOURCE_KLARO: SOURCE_KLARO,
        SOURCE_KLARO_GEO: SOURCE_KLARO_GEO,

        // Functions
        getConsentState: getConsentState,
        getServiceConsentKey: getServiceConsentKey,
        buildConsentMode: buildConsentMode,
        createKlaroForwardedEvent: createKlaroForwardedEvent,
        createKlaroGeoEvent: createKlaroGeoEvent,
        createConsentDataEvent: createConsentDataEvent,
        createConsentReceiptEvent: createConsentReceiptEvent
    };

    klaroGeoLog('DEBUG: KlaroGeoEvents module loaded');
})();
